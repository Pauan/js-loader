How to install
==============

::

  git clone https://github.com/Pauan/js-loader
  cd js-loader
  npm install

What is it?
===========

First I'll tell you what it's **not**:

* It's not a new module system. Just use CommonJS or AMD or globals or whatever.

* It's not a replacement for browserify.

So, what is it, then? It's probably most accurate to call it a `transport format <http://wiki.commonjs.org/wiki/Modules/Transport>`_.

Basically, you want to use CommonJS files in the browser, but that doesn't work because the browser is asynchronous while CommonJS is synchronous.

So then you have things like browserify which can compile CommonJS files to a single big file which can be included in the browser.

And so, what ``js-loader`` does is it makes the task of "take these CommonJS files (and source maps) and mush them into a single big file" a bit easier.

It doesn't handle dependencies, it doesn't minify your files, it just takes JavaScript code + source maps and returns JavaScript code + a source map. That's it.

Some features:

* Modules are only parsed and evaluated when actually used, so the browser can load the JavaScript faster if you load modules on-demand.

* It can combine CommonJS code and code that uses global variables. AMD would be possible to support, but it would bloat up the loader a lot, so it's left out.

* It's *super* small and *super* fast.

* It supports source maps, so if the code has source maps, you'll get back a single big source map for the combined files.

Example
=======

Let's say you had these files:

* foo.coffee

  ::

    { bar } = require "./bar"
    { qux } = require "./qux"
    exports.foo = (x) ->
      bar(x) + qux(x) + 10

* bar.coffee

  ::

    window.bar = (x) ->
      x + 20

If you compile them using ``coffee -cm foo.coffee bar.coffee``, you get these files::

* foo.js

  ::

    // Generated by CoffeeScript 1.6.3
    (function() {
      var bar, qux;

      bar = require("./bar").bar;

      qux = require("./qux").qux;

      exports.foo = function(x) {
        return bar(x) + qux(x) + 10;
      };

    }).call(this);

    /*
    //@ sourceMappingURL=foo.map
    */


* bar.js

  ::

    // Generated by CoffeeScript 1.6.3
    (function() {
      window.bar = function(x) {
        return x + 20;
      };

    }).call(this);

    /*
    //@ sourceMappingURL=bar.map
    */


* foo.js.map

  ::

    {
      "version": 3,
      "file": "foo.js",
      "sourceRoot": "",
      "sources": [
        "foo.coffee"
      ],
      "names": [],
      "mappings": ";AAAA;CAAA,EAAA,GAAA;;CAAA,CAAE,CAAQ,IAAA;;CAAV,CACA,CAAA,IAAO;CADP"
    }

* bar.js.map

  ::

    {
      "version": 3,
      "file": "bar.js",
      "sourceRoot": "",
      "sources": [
        "bar.coffee"
      ],
      "names": [],
      "mappings": ";AAAA;CAAA,CAAA,CAAA,GAAM;CAAN"
    }

In addition, you have an ordinary CommonJS file ``qux.js`` which does not have a source map, since it's just ordinary JavaScript::

  "use strict";
  exports.qux = function (x) {
    return x + 30
  }

You can now combine them together like this::

  var loader = require("js-loader")

  var bundle = new loader.Bundle()

  // 1st argument is the type, which is either "commonjs" or "global"
  // 2nd argument is the module name
  bundle.add("commonjs", "foo", {
    file: "foo.js",        // The file where the JavaScript code is located; defaults to the module name + ".js"
    source: {
      file: "foo.coffee",  // The original filename, corresponds to the "sources" in the source map; defaults to the file
      map: {               // A source map; optional, but if used, must have a file and/or code property
        file: "foo.map"    // The file where the source map is located
      }
    }
  })

  bundle.add("global", "bar", {
    source: {
      file: "bar.coffee",
      map: {
        file: "bar.map"
      }
    }
  })

  // Bundle a CommonJS file that doesn't have a source map
  bundle.add("commonjs", "qux")

  // The module that is automatically loaded when the script runs
  bundle.require("foo")

  // Writes the bundle to the file "bundle.js" and the source map to "bundle.js.map"
  bundle.writeFiles("bundle.js", "bundle.js.map")

And the output is::

* bundle.js

  ::

    // ... contents of require.js go here ...
    define("foo", "// Generated by CoffeeScript 1.6.3\n(function() {\n  var bar, qux;\n\n  bar = require(\"./bar\").bar;\n\n  qux = require(\"./qux\").qux;\n\n  exports.foo = function(x) {\n    return bar(x) + qux(x) + 10;\n  };\n\n}).call(this);\n\n/*\n//@ sourceMappingURL=foo.map\n*/\n\n//# sourceURL=foo.coffee\n//# sourceMappingURL=bundle.js.map")
    global("bar", "// Generated by CoffeeScript 1.6.3\n(function() {\n  window.bar = function(x) {\n    return x + 20;\n  };\n\n}).call(this);\n\n/*\n//@ sourceMappingURL=bar.map\n*/\n\n//# sourceURL=bar.coffee\n//# sourceMappingURL=bundle.js.map")
    define("qux", "\"use strict\";\nexports.qux = function (x) {\n  return x + 30\n}\n//# sourceURL=qux.js")
    require("foo")

* bundle.js.map

  ::

    )]}
    {"version":3,"file":"bundle.js","sources":["foo.coffee","bar.coffee"],"names":[],"mappings":";ACAA,ADAA;CCAA,ADAA,CCAA,CAAA,GAAM,ADAN,EAAA,CCAc;CACZ,EAAI,QAAJ;CADF,ADAA,CAAE,CCAW,ADAH,IAAA;CCAV;CDAA,CACE,CAAQ,IAAA;;CADV,CAEA,CAAA,IAAO,EAAQ;CACT,EAAJ,QAAA;CAHF,EAEc;CAFd","sourcesContent":["{ bar } = require \"./bar\"\n{ qux } = require \"./qux\"\nexports.foo = (x) ->\n  bar(x) + qux(x) + 10","window.bar = (x) ->\n  x + 20"]}

You can then include ``<script src="bundle.js"></script>`` in your HTML page, which will Just Work(tm), including with source maps.

*Note:* the above does not do any minification. You can use ``bundle.transform`` to transform the individual files (e.g. minify them)::

  bundle.transform(function (x) {
    x.type             // Module type, the 1st argument to `add`
    x.name             // Module name, the 2nd argument to `add`
    x.file             // Filename of JavaScript code
    x.code             // JavaScript code as a string
    x.source.file      // Filename of original code
    x.source.code      // Original code as a string
    x.source.map       // Source map; is undefined if the file doesn't have a source map
    x.source.map.file  // Filename of source map
    x.source.map.code  // Source map as a JSON object
  })

You should also minify the "bundle.js" file, and gzip it. This will result in the smallest file size, for super fast downloading!

If you prefer to work with JavaScript code as strings (rather than as files), you can do this instead::

  bundle.add("commonjs", "foo", {
    code: "...",     // Compiled JavaScript code as a string
    source: {
      code: "...",   // Original code as a string
      map: {
        code: "..."  // A source map as a string or JSON object
      }
    }
  })

  // Get the combined code and source map as a string
  bundle.asString("bundle.js", "bundle.js.map", function (code, map) {
    ...
  })

If you use both a ``code`` and ``file`` property, the ``code`` property is used, and the ``file`` property is used *only* for debugging information.

By working with JavaScript strings rather than files, you can write a compiler that targets JavaScript (e.g. CoffeeScript) and generate a single ``bundle.js`` file, without needing to create temporary files. The ``source.code`` property is especially useful for this, since it can be the original, uncompiled (non-JavaScript) code.